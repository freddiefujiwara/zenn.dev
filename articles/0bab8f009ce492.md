---
title: "umount 失敗のあとに rm -rf して Google Drive の中身を消した話（FUSEマウントの罠）"
emoji: "🧨"
type: "tech"
topics: ["bash", "linux", "googleDrive", "fuse", "事故"]
published: true
---

## これは「やらかし」記事です

Google Drive を Linux にマウントして使うために、`google-drive-ocamlfuse` を使っていました。  
ある日、**朝起きたら Google Drive のファイルが0件**になっていて、しばらくフリーズしました。

「何かの事故だ」「Googleに問い合わせよう」  
…そう思ったんですが、原因は自分のスクリプトでした。

---

## 問題のコマンド

当時の自動化（ほぼスクリプト）はこんな感じでした。

```bash
umount GoogleDrive
rm -rf GoogleDrive
mkdir GoogleDrive
google-drive-ocamlfuse -cc -headless -label me -id xxxx -secret xxx GoogleDrive
```

このスクリプト、何が問題かわかりますか。

---

## そう、`umount` の直後に `rm -rf` している

ポイントはここです。

- `GoogleDrive` は **マウントポイント**（= 中身が Google Drive に見えているディレクトリ）
- `umount GoogleDrive` が **失敗**すると、`GoogleDrive` は **マウントされたまま**

その状態で

```bash
rm -rf GoogleDrive
```

を実行すると、`GoogleDrive` ディレクトリを消しているつもりでも、実際には

> **マウントされた Google Drive の中身に対して rm -rf が走る**

という地獄が発生します。

FUSE 系のマウント（`google-drive-ocamlfuse` もそう）だと、ローカルファイル操作がそのままリモートに反映されるので、`rm -rf` は「ローカル掃除」ではなく「Drive 上の全削除」になりえます。

---

## 「仮に umount が失敗したら」本当に吹き飛ぶ

ここが怖いところで、`umount` は普通に失敗します。

たとえば：

- そのディレクトリを別プロセスがカレントディレクトリにしている
- 何かがファイルを開きっぱなし
- FUSE が不調 / 通信状態が微妙
- `umount` ではなく `fusermount -u` が必要な環境だった

なのに当時の自分は、

- `umount` が成功したか（終了ステータス）を見てない
- 失敗してもスクリプトが続行する
- そのまま `rm -rf` が走る

という「事故装置」を自作していました。

---

## 実際に起きたこと

朝起きたら Drive が空。  
自分は本気で「Google側の障害」だと思って、問い合わせる準備をしていました。

でも少し落ち着いて考えて、最近いじったものを思い出し、スクリプトに目がいきました。

そして

- `umount` が何らかの理由で失敗
- それでも `rm -rf GoogleDrive` が実行
- マウントされた Drive に対して削除が伝播

という流れに気づきました。

（この時点で血の気が引きます）

---

## 教訓：マウントポイントに `rm -rf` を置かない

結論はシンプルです。

### ✅ マウントポイントは「消さない」
マウントポイントのディレクトリ自体は、基本的に消す必要がありません。  
多くの場合は

- なければ `mkdir -p`
- すでにあればそのまま使う

で十分です。

---

## どう直すべきだったか（最低限の安全策）

### 1) `umount` に失敗したら止まる

たとえば `&&` でつなぐだけでも「事故率」は下がります。

```bash
umount GoogleDrive && rm -rf GoogleDrive
```

ただし、**そもそもマウントポイントを rm -rf しない**方が安全です。

---

### 2) `set -euo pipefail` を使う（スクリプトなら）

```bash
#!/usr/bin/env bash
set -euo pipefail
```

これで「失敗したコマンドがあったら止まる」ようになります。  
（今回の事故はまさに「失敗しても続行」が原因でした）

---

### 3) `mountpoint` で本当にアンマウントできたか確認する

より安全にするなら、マウント状態を確認します。

```bash
#!/usr/bin/env bash
set -euo pipefail

MP="$HOME/GoogleDrive"

# マウントされているならアンマウントを試みる
if mountpoint -q "$MP"; then
  # FUSE系なら fusermount の方が適切なことが多い
  fusermount -u "$MP"
fi

# マウントポイントは消さない。作るだけ。
mkdir -p "$MP"

google-drive-ocamlfuse -cc -headless -label me -id "$ID" -secret "$SECRET" "$MP"
```

> 「消す」より「確認して止める」「消さない」が大事。

---

## もし同じ事故を起こしたら（メモ）

自分は当時、「完全に終わった」と思いましたが、Google Drive は削除が **ゴミ箱** に入っている可能性があります。

- Google Drive の「ゴミ箱」を確認
- 復元
- Workspace 管理下なら管理者復元（期間制限あり）

…など、状況によっては戻せる可能性があります。  
まずは削除直後に同期や追加操作をしないで、落ち着いて確認した方がいいです。

---

## 最後に：`rm -rf` は悪くない、置き場所が悪い

`rm -rf` 自体が危険というより、

- **「そこが何に繋がっているか」**
- **「直前のコマンドが失敗しても続行する設計」**

が本当に危険です。

マウントポイントは「ただのディレクトリ」ではなく、向こう側（クラウド/別ディスク/別世界）と繋がっている入口です。  
入口の前に爆弾（`rm -rf`）を置くのはやめよう、という話でした。

---

## ちなみに、、ファイルの復元方法
下記のGoogle App Scriptで復活はできます
```js
function restoreAllFromTrash() {
  var files = DriveApp.getTrashedFiles();
  while (files.hasNext()) {
    var file = files.next();
    file.setTrashed(false);
    console.log("復元中: " + file.getName());
  }
  console.log("完了しました。");
}
```
